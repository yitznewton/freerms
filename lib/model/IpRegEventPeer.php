<?php

require 'lib/model/om/BaseIpRegEventPeer.php';


/**
 * Skeleton subclass for performing query and update operations on the 'ip_reg_events' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.1 on:
 *
 * Thu May 13 10:33:23 2010
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model
 */
class IpRegEventPeer extends BaseIpRegEventPeer {
  public static function retrieveAll()
  {
    $c = new Criteria();
    $c->addAscendingOrderByColumn( IpRegEventPeer::OLD_START_IP );
    $c->addAscendingOrderByColumn( IpRegEventPeer::NEW_START_IP );

    return IpRegEventPeer::doSelect( $c );
  }

  public static function fromNew( IpRange $ip_range )
  {
    $acquisitions = AcquisitionPeer::fromIpRange( $ip_range );

    foreach ( $acquisitions as $acquisition ) {
      $ip_reg_event = new IpRegEvent();
      $ip_reg_event->setIpRangeId( $ip_range->getId() );
      $ip_reg_event->setNewStartIp( $ip_range->getStartIp() );
      $ip_reg_event->setNewEndIp( $ip_range->getEndIp() );
      $ip_reg_event->setAcqId( $acquisition->getId() );
      $ip_reg_event->save();
    }
  }

  public static function fromModified( IpRange $before, IpRange $after )
  {
    $acquisitions = AcquisitionPeer::fromIpRange( $before );

    foreach ( $acquisitions as $acquisition ) {
      $c = new Criteria();
      $c->add( IpRegEventPeer::ACQ_ID, $acquisition->getId() );
      $c->add( IpRegEventPeer::IP_RANGE_ID, $after->getId() );

      $ip_reg_event = IpRegEventPeer::doSelectOne( $c );

      if ( $ip_reg_event ) {
        $ip_reg_event->setNewStartIp( $after->getEndIp() );
        $ip_reg_event->setNewEndIp(   $after->getEndIp() );
      }
      else {
        $ip_reg_event = new IpRegEvent();
        $ip_reg_event->setIpRange( $after );
        $ip_reg_event->setAcquisition( $acquisition );
        $ip_reg_event->setOldStartIp( $before->getStartIp() );
        $ip_reg_event->setOldEndIp( $before->getEndIp() );
        $ip_reg_event->setNewStartIp( $after->getStartIp() );
        $ip_reg_event->setNewEndIp( $after->getEndIp() );
      }

      $ip_reg_event->save();
    }
  }

  public static function fromDeleted( IpRange $ip_range )
  {
    $acquisitions = AcquisitionPeer::fromIpRange( $ip_range );

    foreach ( $acquisitions as $acquisition ) {
      $c = new Criteria();
      $c->add( IpRegEventPeer::ACQ_ID, $acquisition->getId() );
      $c->add( IpRegEventPeer::IP_RANGE_ID, $ip_range->getId() );

      $ip_reg_event = IpRegEventPeer::doSelectOne( $c );

      if ( $ip_reg_event && ! $ip_reg_event->getOldStartIp() ) {
        // deleting a newly-added IpRange
        $ip_reg_event->delete();
      }
      elseif ( $ip_reg_event ) {
        $ip_reg_event->setNewStartIp( null );
        $ip_reg_event->setNewEndIp( null );
        $ip_reg_event->save();
      }
      else {
        $ip_reg_event = new IpRegEvent();
        $ip_reg_event->setIpRange( $ip_range );
        $ip_reg_event->setAcquisition( $acquisition );
        $ip_reg_event->setOldStartIp( $ip_range->getStartIp() );
        $ip_reg_event->setOldEndIp( $ip_range->getEndIp() );
      }

      $ip_reg_event->save();
    }
  }
} // IpRegEventPeer
